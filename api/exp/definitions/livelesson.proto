syntax = "proto3";
package syringe.api.exp;

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

service LiveLessonsService {

  // Request a lab is created, or request the UUID of one that already exists for these parameters.
  rpc RequestLiveLesson(LessonParams) returns (LessonUUID) {
    option (google.api.http) = {
      post: "/exp/livelesson"
      body: "*"
    };
  }

  // SetLiveLesson updates certain parameters of an existing LiveLesson, such as setting the LessonStage
  rpc SetLiveLesson(LessonParams) returns (LessonUUID) {
    option (google.api.http) = {
      post: "/exp/livelesson/{lessonId}"
      body: "*"
    };
  }

  // Retrieve details about a lesson
  rpc GetLiveLesson(LessonUUID) returns (LiveLesson) {
    option (google.api.http) = {
      get: "/exp/livelesson/{id}"
    };
  }

  // Retrieve all livelessons
  rpc ListLiveLessons(google.protobuf.Empty) returns (LiveLessons) {
    option (google.api.http) = {
      get: "/exp/livelesson/all"
    };
  }

  // TODO(mierdin): Need to add instrumentation requests, so we can get visibility into the list of livelessons, labdefs, etc.



}

message LiveLessons {
  repeated LiveLessons livelessons = 1;
}

// A provisioned lab without the scheduler details. The server will translate from an underlying type
// (i.e. KubeLab) into this, so only the abstract, relevant details are presented.
message LiveLesson {
  string LessonUUID = 1;
  int32 LessonId = 2;
  repeated Endpoint Endpoints  = 3;
  int32 LessonStage = 4;
  string LabGuide = 5;
  bool Ready = 6;
}

message Endpoint {
  string Name  = 1;

  // This field helps the web client understand how to connect to this endpoint. Some might be done via SSH/Guacamole, others might be iframes, etc.
  enum EndpointType {
    UNKNOWN = 0;       // In proto3, zero value fields are indistinguishable from unset fields, by design. They are not sent on the wire either. So let's set this aside.
    DEVICE = 1;        // A network device. Expected to be reachable via SSH or API on the listed port
    NOTEBOOK = 2;      // Jupyter notebook server
    BLACKBOX = 3;      // Some kind of entity that the user doesn't have access to (i.e. for troubleshooting). Effectively the same as UTILITY but we don't present this to the user in any way on the web UI
    UTILITY = 4;       // Linux container we want to provide access to for tools. Handled pretty much the same as DEVICE, as we SSH to this.
  }
  EndpointType Type = 2;

  // Port for normal operations. If type "device", used for SSH. If type "notebook", loads up in an iframe.
  int32 Port  = 3;

  // Extra port for API interactions.
  // Note that this mostly doesn't matter, as this is only in case we want to allow API interactions from outside
  // the cluster via NodePort. Most of the time we'll use the standard ports using in-cluster traffic.
  int32 Api_port  = 4;
}

message LessonParams {
  int32 lessonId = 1;
  string sessionId = 2;
  int32 lessonStage = 3;
}

message LessonUUID {
  string id = 1;
}


